\documentclass[a4paper, 12pt]{article}

\usepackage[italian]{babel}   % Per la divisione sillabica delle parole
\usepackage{url}              % Per creare url
\usepackage{float}            % Lets you prevent LaTeX from repositioning the tables
\usepackage{amsmath}          % Per utilizzare il blocco `align`
\usepackage{microtype}        % Per evitare il problema del 'overfull hbox' con \texttt


% Title Page
\title{\textbf{Relazione laboratori}\\
        \normalsize Corso di Computer Graphics - Università di Bologna}
\author{Daniele Polidori\\ daniele.polidori2@studio.unibo.it}
\date{a.a. 2022-23}


\begin{document}

\maketitle

\pagenumbering{arabic}


\section{LAB-01}

\paragraph{Punto 4b.}
Nello svolgimento del primo laboratorio, per quanto riguarda il punto 4, ho scelto di svolgere l'opzione \textit{b}.\\
Oltre ai VAO già in uso per la curva di base, ho creato una seconda coppia di VAO per disegnare il tratto cubico che di volta in volta viene creato. Questo, una volta completato, viene attaccato alla curva di base: i punti relativi al tratto cubico vengono aggiunti a quelli della curva di base, così da liberare lo spazio per un possibile nuovo tratto cubico, e così via.\\
L'utente può scegliere la continuità con cui attaccare i tratti cubici alla curva di base: la continuità $C^0$ premendo il tasto \textit{0} (scelta di default), $C^1$ premendo il tasto \textit{1} e $G^1$ premendo il tasto \textit{g}. Tale continuità rimarrà selezionata finché non ne verrà scelta una differente.\\
I tratti successivamente creati verranno raccordati con la continuità selezionata. Siano $p_0, \dots, p_n$ i punti della curva di base e $v_0, \dots, v_3$ i punti del tratto cubico, le continuità vengono applicate nella maniera seguente. $v_0$ viene eliminato, sarà infatti sostituito da $p_n$. A partire dalle coordinate di $p_{n-1}$ e $p_n$ vengono calcolate le coordinate che deve assumere il punto $v_1$, così che la continuità venga soddisfatta. Viene applicata la formula \eqref{eq:C1} per ottenere la continuità $C^1$ e la formula \eqref{eq:G1} per la continuità $G^1$: tali formule vengono applicate separatamente sulle coordinate $x$ e sulle $y$ dei rispettivi punti, con $\Delta = p_3 - p_2$. Per la continuità $G^1$, il punto verrà posizionato in modo tale che il tratto $v_1 - p_n$ sia lungo la metà del tratto $p_n - p_{n-1}$. Infine, i punti $v_1$, $v_2$ e $v_3$ vengono aggiunti alla curva di base, in qualità di, rispettivamente, $p_{n+1}$, $p_{n+2}$ e $p_{n+3}$.
\begin{align}
  v_1' &= p_n + \Delta = 2*p_n - p_{n-1}             \label{eq:C1} \\
  v_1' &= p_n + \frac{\Delta}{2} = p_n + \frac{p_n - p_{n-1}}{2}   \label{eq:G1}
\end{align}

\paragraph{Punto 5.}
Per realizzare lo spostamento dei punti tramite trascinamento con il mouse, mi sono servito delle funzioni callback di OpenGL: \texttt{glutMouseFunc()} e \texttt{glutMotionFunc()}.\\
Tramite la prima, quando viene premuto il tasto destro del mouse, controllo se mi trovo sopra un punto. Per facilitare la presa, considero un intorno delle coordinate dei punti: dato un punto $(x,y)$, anziché le coordinate strette $x$ e $y$, cerco dei valori più laschi, rispettivamente negli intervalli $[x-0.01, x+0.01]$ e $[y-0.01, y+0.01]$. Se il mouse si trova sopra un punto, questo viene ``agganciato'' (i.e. un puntatore punta alla sua cella di memoria) e quando poi rilascio il tasto, il punto viene ``sganciato''.\\
Tramite la seconda, invece, catturo la posizione del mouse durante il trascinamento del punto. Se un punto è stato agganciato, sostituisco le coordinate di tale punto con le coordinate del mouse in ogni istante. I valori continuano a mutare fino a che il punto non viene sganciato, ovvero finché il tasto del mouse non viene rilasciato.


\section{LAB-02}

\paragraph{}
Nello svolgimento del secondo laboratorio ho deciso di riprodurre un cielo notturno dove si trovano dieci piccole fonti di luce (detti aloni) e un cerchio di luce più grande (detto sole), che segue il movimento del mouse.\\
Quando il sole (i.e. il mouse) passa sopra un alone, quest'ultimo scompare (dando l'effetto di venire inglobato dal sole). Se il sole tocca uno dei bordi dello schermo, si incorre in una penalità: tutti gli aloni inglobati tornano alla loro posizione iniziale (in questo modo la partita ricomincia da capo).\\
Lo scopo del gioco è inglobare (i.e. passare con il sole sopra) tutti gli aloni.\\
Presentiamo ora il modo in cui sono stati realizzati i vari oggetti presenti nella scena: il cielo, gli aloni, il sole e i sistemi particellari.

\paragraph{Cielo.}
Ho preso l'oggetto del cielo dal programma \texttt{2D\_Jumping\_Ball.cpp} e l'ho collegato a \texttt{VAO\_CIELO} e a \texttt{VAO\_ANIMAZIONECIELO}. Ne ho modificato la posizione e la scala (modificando l'input delle funzioni \texttt{translate()} e \texttt{scale()}, nella funzione \texttt{drawScene()}), in modo tale da riempire tutto lo schermo a disposizione. Ne ho modificato anche il colore (cambiando il valore delle variabili \texttt{col\_top} e \texttt{col\_bottom}, nella funzione \texttt{init()}), così da rendere il cielo notturno.\\
Ho aggiunto poi un'animazione al cielo. Per farlo, ho preso l'oggetto dell'alone del sole dal programma \texttt{2D\_Jumping\_Ball.cpp}. Ne ho modificato la scala (modificando l'input della funzione \texttt{scale()}, nella funzione \texttt{drawScene()}), in modo tale da ingigantire l'alone nello scermo. Ne ho modificato il colore e la trasparenza (cambiando il valore della variabile \texttt{col\_bottom\_sole}, nella funzione \texttt{disegna\_luce()}), così da renderlo un chiarore vagamente riconoscibile. Infine, nella funzione \texttt{drawScene()}, ho creato contemporaneamente cinque aloni nel cielo, in posizioni casuali. Questi, a intervallo di tempo regolare, cambiano posizione, sempre in maniera casuale. L'effetto ottico che ne deriva è quello di un cielo dinamico, mostrando un vago movimento indistinguibile sullo sfondo.

\paragraph{Aloni.}
Ho preso l'oggetto dell'alone del sole dal programma \texttt{2D\_Jumping\allowbreak\_Ball.cpp} e l'ho collegato a \texttt{VAO\_SOLE}. Ne ho modificato la scala (modificando l'input della funzione \texttt{scale()}, nella funzione \texttt{drawScene()}), in modo tale da renderlo una piccola fonte di luce. Ne ho modificato anche il colore (cambiando il valore della variabile \texttt{col\_bottom\_sole}, nella funzione \texttt{disegna\_sole()}), rendendolo più chiaro.\\
All'inizio della partita, nella funzione \texttt{drawScene()}, creo contemporaneamente dieci aloni nel cielo, in posizioni casuali. Successivamente vengono mostrati soltanto quelli che ancora non sono stati inglobati. Se il sole tocca un bordo dello schermo, vengono mostrati nuovamente tutti gli aloni.

\paragraph{Sole.}
Ho preso l'oggetto del sole (con il suo alone) dal programma \texttt{2D\allowbreak\_Jumping\_Ball.cpp} e l'ho collegato a \texttt{VAO\_SOLE}. Ne ho modificato la scala (modificando l'input della funzione \texttt{scale()}, nella funzione \texttt{drawScene()}), per renderlo leggermente più piccolo. Ne ho modificato anche il colore (cambiando il valore delle variabili \texttt{col\_top\_sole} e \texttt{col\_bottom\_sole}, nella funzione \texttt{disegna\_sole()}), rendendolo più chiaro.\\
Infine, ho agganciato il sole al movimento del mouse: ho sostituito l'input della funzione \texttt{translate()} con delle variabili che memorizzano la posizione attuale del mouse (il loro valore viene continuamente aggiornato attraverso la funzione callback di OpenGL \texttt{glutPassiveMotionFunc()}).\\
Quando un alone viene inglobato, l'alone del sole viene ingrandito, per mostrare il progresso nella dinamica di gioco. Se il sole tocca un bordo dello schermo, l'alone del sole torna alla sua dimensione iniziale.\\
In caso di vittoria, l'alone del sole viene ingrandito progressivamente (senza mai fermarsi). Per realizzare questo effetto ho usato cinquanta chiamate ricorsive alla funzione \texttt{aumentaScala\_aloneSole()}, attraverso la funzione \texttt{glutTimerFunc()}, ciascuna delle quali applica un piccolo incremento alla scala dell'alone del sole.

\paragraph{Sistemi Particellari.}
Ho preso l'oggetto del sistema particellare dal programma \texttt{2D\_PS.cpp} e l'ho collegato a \texttt{VAO\_SISTEMAPARTICELLARE}. Tale oggetto è stato utilizzato in più punti.\\
Come prima cosa, l'ho collegato al movimento del mouse (attraverso la funzione \texttt{glutPassiveMotionFunc()}) e ne ho cambiato il colore (impostando il giallo nel valore della variabile \texttt{rgb}, presente nella funzione).\\
Inoltre, nella funzione \texttt{drawScene()}, ho creato, in ciascuna posizione degli aloni, un piccolo sistema particellare di colore arancione (indicato nel valore della variabile \texttt{rgb}, presente nella funzione). Tale sistema particellare viene mostrato soltanto nelle posizioni degli aloni che non sono stati ancora inglobati.\\
Infine, ho utilizzato questo oggetto per segnalare visivamente un'azione negativa, quando essa viene compiuta dall'utente. Infatti, quando il sole tocca un bordo dello schermo, il cielo si riempie di un sistema particellare di colore rosso (indicato nel valore della variabile \texttt{rgb}, nella funzione \texttt{glutPassiveMotionFunc()}), diffuso uniformemente in tutta l'area dello schermo.


\section{LAB-03}

\paragraph{Punto 1a.}
La scelta dello shading da applicare in scena è riferito solo all'oggetto \textit{Bunny} (\texttt{Mesh/bunny.obj}).\\
Nella funzione \texttt{buildOpenGLMenu()}, ho creato un sottomenù, nel menu principale del programma, per consentire la modifica dello shading. Quando viene selezionato uno shading differente, viene invocata la funzione \texttt{init\_mesh()}, che sostituisce il vecchio oggetto (memorizzato nella variabile \texttt{objects}) con uno nuovo. Questo, se la scelta è diversa dal Flat shading, conterrà le normali ai vertici (anziché quelle alle facce), mentre per il resto rimarrà identico.\\
Il calcolo delle normali ai vertici $\overrightarrow{Nv}$, viene eseguito nella funzione \texttt{loadObjFile()}. Cerco, per ciascun vertice \textit{i}, le \textit{n} facce che lo condividono, quindi applico la formula per il calcolo della normale al vertice:
\[ \overrightarrow{Nv_i} = \frac{\sum_{k=1}^n \overrightarrow{Nf_{i,k}}}{n} \]
con $\overrightarrow{Nf_{i,k}}$ la normale alla k-esima faccia condivisa dal vertice \textit{i}.\\
Nella variabile \texttt{vertexIndices} vengono memorizzati gli indici dei vertici (decrementati di 1), ordinati seguendo le dichiarazioni delle facce nel file (con estensione \texttt{.obj}) del rispettivo oggetto. Dal momento che le normali ai vertici vengono calcolate e memorizzate seguendo i vertici in ordine crescente, l'indice di ciascuna di esse corrisponde a quello del rispettivo vertice (già decrementato di 1). La variabile \texttt{normalIndices} viene quindi riempita con i valori presenti in \texttt{vertexIndices}.

\paragraph{Punto 1b.}
Ho definito i valori di un nuovo materiale, che ho chiamato \textit{My Material}. Poi, nella funzione \texttt{init()}, l'ho aggiunto nella variabile \texttt{materials}. Infine, ho aggiunto la rispettiva voce nel sottomenù dei materiali, per renderlo selezionabile.

\paragraph{Punto 1d.}
Ho creato il vertex shader \texttt{Shaders/v\_wave.glsl}, per l'oggetto \textit{Wave}. Questo prende in input i vertici e le normali (nelle variabili \texttt{vPosition} e \texttt{vNormal}). Dall'applicazione gli vengono passati (nelle funzioni \texttt{initShader()} e \texttt{drawScene()}) i valori delle variabili \texttt{time}, \texttt{P}, \texttt{V}, \texttt{M}, \texttt{light} e \texttt{material}. In output viene restituita la variabile \texttt{Color}.\\
L'illuminazione viene gestita all'interno del vertex shader. Il fragment shader che gli ho associato (nella funzione \texttt{initShader()}) è quello relativo al Gouraud shading (\texttt{Shaders/\allowbreak f\_gouraud.glsl}), che semplicemente prende in input \texttt{Color} e lo restituisce come \texttt{FragColor}.\\
Per una resa migliore del movimento ondoso, ho  aumentato il valore in input alla funzione \texttt{refresh\_monitor()}, nella funzione \texttt{main()}: in questo modo il moto viene rallentato, rendendolo più piacevole alla vista.

\paragraph{Punto 1e.}
Il Toon shading viene applicato solo all'oggetto \textit{Bunny}.\\
Ho creato il vertex shader \texttt{Shaders/v\_toon.glsl} e il fragment shader \texttt{Shaders/\allowbreak f\_toon.glsl}. Il primo prende in input i vertici e le normali (nelle variabili \texttt{vPosition} e \texttt{vNormal}); dall'applicazione gli vengono passati (nelle funzioni \texttt{initShader()} e \texttt{drawScene()}) i valori delle variabili \texttt{P}, \texttt{V}, \texttt{M} e \texttt{light}; in output vengono restituite le variabili \texttt{N}, \texttt{L} ed \texttt{E}. Queste vengono prese in input dal fragment shader, che restituisce in output la variabile \texttt{FragColor}.\\
Anche per il Toon shading vengono calcolate le normali ai vertici.\\
Ho aggiunto la rispettiva voce nel sottomenù degli shading, per renderlo selezionabile.

\paragraph{Punto 2.}
Nelle funzioni \texttt{moveCameraLeft()} e \texttt{moveCameraRight()}, per realizzare la funzionalità \textit{Pan oriz. camera (sx/dx)}, ho calcolato il vettore direzione $\vec{A} - \vec{C}$ (nella variabile \texttt{direction}) tra la posizione della camera ($\vec{C}$) e del punto di riferimento in scena ($\vec{A}$). Ho poi calcolato, nella variabile \texttt{slide\_vector}, il prodotto vettoriale tra il suddetto vettore direzione e l'Up Vector della camera. Tale vettore, che definisce lo spostamento da compiere, viene sottratto, in \texttt{moveCameraLeft()}, e rispettivamente sommato, in \texttt{moveCameraRight()}, ai vettori $\vec{A}$ e $\vec{C}$.

\paragraph{Punto 3.}
Nella funzione \texttt{modifyModelMatrix()} applico le trasformazioni di traslazione, rotazione e scalatura degli oggetti in scena. L'oggetto e il sistema di riferimento rispetto al quale operare (WCS o OCS), sono quelli che in quel momento sono selezionati. Le trasformazioni vengono applicate alla matrice (la variabile \texttt{M}) dell'oggetto (contenuto nella variabile \texttt{objects}).


%\begin{thebibliography}{90}
%\bibitem{K1} \url{https://github.com/danielepolidori/LabComputerGraphics}\\
%- repository GitHub di questo lavoro.
%\end{thebibliography}


\end{document}
 
